# Extraction of Salt core modules

## Scripted example
Based on the [manual example below](manual-extraction-example), a new tool named [saltext-migrate](https://github.com/salt-extensions/salt-extension-migrate) was created.

Let's use the same example module (`stalekey`).

### 1. Install `saltext-migrate` and `git-filter-repo`

:::{tab} pipx
```bash
pipx install git-filter-repo
pipx install git+https://github.com/salt-extensions/salt-extension-migrate
```
:::
:::{tab} pip
```bash
pip install git-filter-repo git+https://github.com/salt-extensions/salt-extension-migrate
```
:::

### 2. Run the tool

:::{important}
Ensure you're running the tool inside a dedicated directory that will serve as the working directory for all your Salt extension migrations.

This will avoid accidental data loss and speed up repeated migrations.
:::

```bash
mkdir migrated-saltexts && cd migrated-saltexts
saltext-migrate stalekey
```

It will

1. [ensure Salt is cloned and the history analysis available](clone-the-salt-repo-and-analyze-its-history)
2. filter for paths containing `stalekey`, asking for approval, then
3. [filter the history into a separate branch](filter-the-history-into-a-separate-branch), renaming paths as needed
4. auto-[cleanup the history](clean-up-the-history), as far as possible non-interactively
5. [run copier](populate-the-extension-repo) (some questions like {question}`loaders` are populated automatically) and remove the project starter boilerplate
6. [create a virtualenv](create-a-virtualenv-and-activate-it) for your project
7. [apply rewrites](clean-up-and-test)
8. install & run pre-commit
9. provide an overview of issues to fix and next steps

(manual-extraction-example)=
## A manual module extraction example
Below are some rough steps that extract an existing set of modules into an extension while preserving the Git history. Let's use the `stalekey` engine as an example.

### 1. Install the Git history filtering tool

:::{tab} pipx
```shell
pipx install git-filter-repo
```
:::
:::{tab} pip
```shell
pip install git-filter-repo
```
:::

### 2. Clone the Salt repo and analyze its history

```shell
mkdir workdir && cd workdir
git clone https://github.com/saltstack/salt --single-branch
cd salt
git filter-repo --analyze
tree .git/filter-repo/analysis/
grep stalekey .git/filter-repo/analysis/path-{all,deleted}-sizes.txt | \
    awk '{print $5}' | sort | uniq | \
    grep -vE '^(.github|doc/ref|debian/|doc/locale|salt/([^/]+/)?__init__.py|tests/(pytests/)?(unit|functional|integration)/conftest.py)'
```

The main goal here is to find all relevant files (modules, utils, automated tests, fixtures, documentation). For the `stalekey` engine that would be:

* `salt/engines/stalekey.py` - the engine itself
* `tests/unit/engines/test_stalekey.py` - old style unit tests (historic path, does not exist in HEAD anymore)
* `tests/pytests/unit/engines/test_stalekey.py` - new style unit-tests that use pytest

### 3. Filter the history into a separate branch

```shell
git checkout -b filter-source
git filter-repo \
    --path salt/engines/stalekey.py \
    --path-rename salt/engines/stalekey.py:src/saltext/stalekey/engines/stalekey.py \
    --path tests/pytests/unit/engines/test_stalekey.py \
    --path-rename tests/pytests/unit/engines/test_stalekey.py:tests/unit/engines/test_stalekey.py \
    --path tests/unit/engines/test_stalekey.py \
    --refs refs/heads/filter-source --force
```

The `--path-rename` option is needed to move the files into a different directory structure used by Salt extensions.

### 4. Clean up the history

```shell
git log --name-only
git rebase -i --empty=drop --root --committer-date-is-author-date
```

The main goal here is to delete the commits that do not touch any of the extracted files, and also delete the last commit that removes them. The merge commits seem to be deleted automatically during the rebase.

While looking at the Git log, please note the major contributors (to add them as code authors later).

### 5. Populate the extension repo

When answering the Copier questions, choose the `engine` module type only, specify yourself as an author:

```shell
cd ..
mkdir saltext-stalekey && cd saltext-stalekey
git init --initial-branch=main
copier copy --trust https://github.com/salt-extensions/salt-extension-copier ./
```

We need to remove some boilerplate files generated by Copier:

```shell
rm -f tests/**/test_*.py src/**/*_mod.py
```

And then merge the history:

```shell
git remote add repo-source ../salt
git fetch repo-source
git merge repo-source/filter-source
git remote rm repo-source
git tag | xargs git tag -d
```

### 6. Create a virtualenv and activate it

To create the virtualenv, it is recommended to use the same Python version (MAJOR.MINOR) as the one [listed here](https://github.com/saltstack/salt/blob/master/cicd/shared-gh-workflows-context.yml).

```shell
python3.10 -m venv venv --prompt saltext-stalekey
source venv/bin/activate
```

Please ensure you're inside your virtual environment from here on.

### 7. Clean up and test

Run the automatic fixups:

```shell
pip install git+https://github.com/saltstack/salt-rewrite
SALTEXT_NAME=stalekey salt-rewrite -F fix_saltext .
```

:::{important}
You might need to rewrite some imports again, the `salt-rewrite` tool currently
assumes that your project is named `saltext.saltext_stalekey`, not `saltext.stalekey`.
:::

```shell
pip install -e ".[dev,tests,docs]"
pre-commit install --install-hooks
pre-commit run -a  # make sure it is happy
git status
git add .
git commit -m 'Add extension layout'
```

Add the main authors to pyproject.toml:

```shell
vi pyproject.toml
git add pyproject.toml
git commit -m 'Add authors'
```

Try [running the test suite](run-tests-target) and [building the docs](build-docs-target) locally until both pass, then commit and push it to run the full test suite on GitHub.

## Basic fixes (automated)
### Unit test module imports

Unit tests import the modules directly. After migration, these imports
need to be adjusted, otherwise the tests will run against the modules found in Salt,
but still pass (or fail once they are removed in a future release). Example:

:::{tab} old
```python
from salt.modules import vault
```
:::

:::{tab} correct
```python
from saltext.vault.modules import vault
```
:::

### Unit test `tests.support` imports

Many unit tests in the Salt code base use an indirect import for `unittest.mock`.
Ensure you update them.

:::{tab} old
```python
from tests.support.mock import MagicMock, Mock, patch
```
:::

:::{tab} correct
```python
from unittest.mock import MagicMock, Mock, patch
```
:::

### Migrated tests in `tests/pytest`

All tests in Salt core that were migrated to Pytest are found in `tests/pytests`.
After a migration, this directory is replicated to the Saltext project, but
Salt extension projects assume that all tests are Pytest-based and found in `tests` directly.
To ensure everything works as expected, you should remove the `pytest` part
of the path by moving the tests one level up.

## Issues needing manual fixing
(utils-dunder-into-saltext-utils)=
### `__utils__` into Salt extension utils

Some Salt core modules access their utilities via the `__utils__` dunder instead of direct imports,
which ensures that the called utility function has access to Salt's global dunders.

Accessing a Salt extension's `utils` this way does not work. If this is the case for your extracted set of modules,
you need to adjust the `utils` to not rely on the dunders, e.g. by passing in the required
references:

:::{tab} old

```python
# ------- salt.modules.foo ---------------
def get(entity):
    return __utils__["foo.query"](entity)
```

```python
# ------- salt.utils.foo -----------------
def query(entity):
    base_url = __opts__.get("foo_base_url", "https://foo.bar")
    profile = __salt__["config.option"]("foo_profile")
    return __utils__["http.query"](base_url, data=profile)
```
:::

:::{tab} correct
```python
# ------- saltext.foo.modules.foo -------
from saltext.foo.utils import foo


def get(entity):
    base_url = __opts__.get("foo_base_url", "https://foo.bar")
    return foo.query(base_url, entity, __salt__["config.option"])
```
```python
# ------- saltext.foo.utils.foo -------
import salt.utils.http


def query(base_url, entity, config_option):
    profile = config_option("foo_profile")
    return salt.utils.http.query(base_url, data=profile)
```
:::

(utils-dunder-from-saltext-utils)=
### `__utils__` from Salt extension utils
Some modules in `salt.utils` currently still expect to be called via `__utils__`.

This is not a problem when you're calling them from modules that are loaded via the Salt loader (all {question}`loaders`).

On the other hand, if your Saltext utils currently call them, this cannot work.

Some potential starting points:

* Remove the dependency on the core module or call them from the modules calling the utils module directly
* Migrate the dependency into the Salt extension repository and modify it locally as described [here](utils-dunder-into-saltext-utils)
* Submit a PR with the above changes to Salt core to be able to get rid of this code duplication at some point

(utils-dunder-into-salt-utils)=
### `__utils__` from other Salt extension modules
If any other Saltext module depends on a Salt core utility module that requires being called via `__utils__`,
this is not a problem. You should still consider creating a PR that removes this requirement since
[`__utils__` is scheduled for deprecation](https://github.com/saltstack/salt/issues/62191) at some point.

(pre-pytest-tests)=
### Pre-pytest tests

Not all Salt core tests have been converted to Pytest. You might need to convert them
in order to keep them running. If you want to skip this task for now, you need to

* exclude the corresponding files from `pylint`
* skip the corresponding tests completely

```python
# pylint: disable-all
import pytest

pytest.skip(reason="Old non-pytest tests", allow_module_level=True)
```

## Considerations
(library-dependencies)=
### Library dependencies

Some modules have library dependencies. Since they were included in Salt core,
which cannot possibly be shipped with every dependency,
they needed to account for the library not being present.
They typically use the following stanza to avoid a crash during import:

```python
HAS_LIBS = False

try:
    import foo
    HAS_LIBS = True
except ImportError:
    pass

__virtualname__ = "foobar"


def __virtual__():
    if HAS_LIBS:
        return __virtualname__
    return False, "Missing 'foo' library"
```

If the dependencies are all hard dependencies, you should declare them as such in your Saltext's
`pyproject.toml` (in `dependencies`) and remove the conditional loading:

```python
import foo

__virtualname__ = "foobar"


def __virtual__():
    return __virtualname__
```

Other modules can work with several, interchangeable libraries. For this case, you should at least
declare a dependency on one of the choices in your `optional-dependencies` for `tests`
in order to make the tests run.

(dedicated-docs)=
### Dedicated docs

Salt core modules are documented inline. You should consider extracting general parts of the
inline documentation into a separate topic inside the `docs/topics` directory.
